import { createApiError, createApiResponse, isApiError } from "~/server/utils/response"

interface BGPPrefix {
  prefix: string
  exact?: boolean
}

interface RouteROSData {
  ipv4Ranges: string[]
  ipv6Ranges: string[]
  script: string
  lastUpdated: string
  cacheHit: boolean
}

// Simulated cache (in production this would be KV storage)
let cachedData: RouteROSData | null = null
let lastFetch = 0
const CACHE_TTL = 3600000 // 1 hour

async function fetchPutIOData(): Promise<RouteROSData> {
  try {
    // Fetch from RIPE STAT API
    const ripeResponse = await fetch("https://stat.ripe.net/data/announced-prefixes/data.json?resource=AS9009")
    let ipv4Ranges: string[] = []
    let ipv6Ranges: string[] = []

    if (ripeResponse.ok) {
      const ripeData = await ripeResponse.json()
      const prefixes = ripeData.data?.prefixes || []

      for (const prefix of prefixes) {
        if (prefix.prefix) {
          if (prefix.prefix.includes(":")) {
            ipv6Ranges.push(prefix.prefix)
          } else {
            ipv4Ranges.push(prefix.prefix)
          }
        }
      }
    }

    // Fallback to BGPView API if RIPE fails or has no data
    if (ipv4Ranges.length === 0 && ipv6Ranges.length === 0) {
      const bgpResponse = await fetch("https://api.bgpview.io/asn/9009/prefixes")
      if (bgpResponse.ok) {
        const bgpData = await bgpResponse.json()
        const prefixes = bgpData.data?.ipv4_prefixes || []
        const ipv6Prefixes = bgpData.data?.ipv6_prefixes || []

        ipv4Ranges = prefixes.map((p: BGPPrefix) => p.prefix)
        ipv6Ranges = ipv6Prefixes.map((p: BGPPrefix) => p.prefix)
      }
    }

    // Generate RouterOS script
    const script = generateRouterOSScript(ipv4Ranges, ipv6Ranges)

    const data: RouteROSData = {
      ipv4Ranges,
      ipv6Ranges,
      script,
      lastUpdated: new Date().toISOString(),
      cacheHit: false
    }

    // Cache the data
    cachedData = data
    lastFetch = Date.now()

    return data
  } catch (error) {
    console.error("Error fetching put.io data:", error)
    throw new Error("Failed to fetch put.io IP ranges")
  }
}

function generateRouterOSScript(ipv4Ranges: string[], ipv6Ranges: string[]): string {
  const lines: string[] = []

  lines.push("# RouterOS script for put.io IP ranges")
  lines.push("# Generated by dave.io API")
  lines.push(`# Generated at: ${new Date().toISOString()}`)
  lines.push("")

  lines.push("# Remove existing put.io address lists")
  lines.push('/ip firewall address-list remove [find list="putio"]')
  lines.push('/ipv6 firewall address-list remove [find list="putio"]')
  lines.push("")

  if (ipv4Ranges.length > 0) {
    lines.push("# Add IPv4 ranges")
    for (const range of ipv4Ranges) {
      lines.push(`/ip firewall address-list add list=putio address=${range} comment="put.io IPv4"`)
    }
    lines.push("")
  }

  if (ipv6Ranges.length > 0) {
    lines.push("# Add IPv6 ranges")
    for (const range of ipv6Ranges) {
      lines.push(`/ipv6 firewall address-list add list=putio address=${range} comment="put.io IPv6"`)
    }
    lines.push("")
  }

  lines.push("# Script completed")
  lines.push(`:log info "put.io address list updated: ${ipv4Ranges.length} IPv4, ${ipv6Ranges.length} IPv6 ranges"`)

  return lines.join("\n")
}

export default defineEventHandler(async (event) => {
  try {
    const query = getQuery(event)
    const format = (query.format as string) || "script"

    // Check cache
    const now = Date.now()
    let data: RouteROSData

    if (cachedData && now - lastFetch < CACHE_TTL) {
      data = { ...cachedData, cacheHit: true }
    } else {
      data = await fetchPutIOData()
    }

    // Return based on format
    switch (format) {
      case "json":
        return createApiResponse(
          {
            ipv4Count: data.ipv4Ranges.length,
            ipv6Count: data.ipv6Ranges.length,
            ipv4Ranges: data.ipv4Ranges,
            ipv6Ranges: data.ipv6Ranges,
            lastUpdated: data.lastUpdated,
            cacheHit: data.cacheHit
          },
          "put.io IP ranges retrieved successfully"
        )
      default:
        setHeader(event, "Content-Type", "text/plain")
        setHeader(event, "Content-Disposition", 'attachment; filename="putio-routeros.rsc"')
        return data.script
    }
  } catch (error: unknown) {
    console.error("RouterOS put.io error:", error)

    if (isApiError(error)) {
      throw error
    }

    throw createApiError(500, "RouterOS script generation failed")
  }
})
