# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

api.dave.io is a multipurpose personal API powered by Cloudflare Workers. It provides several endpoints:

- **Ping**: Simple health check endpoint
- **Redirect**: URL redirection service using KV storage
- **Dashboard**: Data feeds for dashboards (demo and Hacker News available)
- **RouterOS**: Generates RouterOS scripts for network configurations (currently implements put.io IP ranges, with more providers planned)
- **Metrics**: View API metrics in JSON, YAML, or Prometheus format
- **Authentication**: JWT-based authentication system with scope-based authorization

The API is built with [Hono](https://hono.dev) and uses [Chanfana](https://github.com/cloudflare/chanfana) for OpenAPI documentation and schema validation.

## Development Commands

### Setup and Development

```bash
# Install dependencies
bun install

# Start development server
bun run dev

# Generate Cloudflare Workers type definitions
bun run types

# Deploy to Cloudflare Workers
bun run deploy

# Run TypeScript type checking
bun run typecheck

# Lint code with Trunk and Biome
bun run lint

# Format code with Trunk
bun run format

# Run KV backup/restore utility
bun kv backup           # Backup KV data matching patterns
bun kv backup --all     # Backup all KV data
bun kv restore <file>   # Restore KV data from backup
bun kv wipe             # Wipe all KV data (DANGEROUS!)

# Generate JWT tokens for authentication
bun run jwt --help      # Show JWT generation help
bun run jwt --interactive  # Interactive JWT generation
bun run jwt --sub user123 --scopes "read,metrics" --expires "24h"
```

## Code Architecture

- **Framework**: Uses Hono.js for routing and HTTP server functionality
- **API Documentation**: Uses Chanfana (OpenAPI) for documentation and schema validation
- **Type Safety**: Uses TypeScript and Zod for runtime type validation
- **Schema Organization**: Schemas are defined in `src/schemas/` directory using Zod
- **KV Storage**: Uses a unified KV namespace with hierarchical keys for data organization
- **Analytics**: Uses Cloudflare Analytics Engine for request tracking

### Middleware Pipeline

The application uses a series of middleware to handle requests:

1. **KV Initialization**: Initializes KV with default values at startup
2. **Analytics Tracking**: Captures detailed request info for analytics
3. **Metrics Tracking**: Monitors non-success/non-redirect responses
4. **Endpoint Handlers**: Individual handlers for specific routes

### TypeScript Type Management

The project relies on Cloudflare Workers type definitions from the auto-generated `worker-configuration.d.ts` file. This approach ensures type definitions are always up-to-date with the current Wrangler configuration.

Key aspects of the type system:

1. **worker-configuration.d.ts**: Auto-generated by Wrangler (`bun run types`)

- Contains all Cloudflare Workers types (KVNamespace, etc.)
- Reference with `/// <reference path="../../worker-configuration.d.ts" />`

2. **src/schemas/cloudflare.types.ts**:

- Extends the auto-generated types with project-specific additions
- Adds custom environment bindings to the `Env` interface
- Provides type safety for Cloudflare bindings

3. **Type Checking**:

- Run `bun run typecheck` to verify type correctness
- Ensures proper usage of Cloudflare Workers types throughout the codebase

## JWT Authentication System

The API includes a comprehensive JWT-based authentication system with scope-based authorization:

### Authentication Features

- **JWT Token Support**: Secure token-based authentication using industry standards
- **Scope-Based Authorization**: Fine-grained permissions using scopes
- **Multiple Token Sources**: Accepts tokens via `Authorization: Bearer` header or `?token=` query parameter
- **CLI Token Generation**: Built-in tool for generating tokens during development
- **Middleware Integration**: Easy-to-use middleware for protecting endpoints

### Using Authentication in Endpoints

To protect an endpoint, apply the `requireAuth()` middleware. **Important**: The middleware returns a Response object when authentication fails, so you must check for and handle this properly:

```typescript
import { requireAuth, type AuthorizedContext } from "../lib/auth"
import type { Context } from "hono"

// In your endpoint's handle method:
async handle(c: Context) {
  // Create the authentication middleware
  const authMiddleware = requireAuth()

  // The middleware will return a Response if authentication fails
  // We need to capture and check the result
  let authResult: Response | void

  try {
    authResult = await authMiddleware(c, async () => {
      // This empty function will only be called if auth succeeds
    })
  } catch (error) {
    console.error("Auth middleware error:", error)
    return c.json({ error: "Authentication failed" }, 500)
  }

  // If the middleware returned a Response, it means auth failed
  if (authResult instanceof Response) {
    return authResult
  }

  // If we get here, authentication succeeded
  const authContext = c as AuthorizedContext
  console.log("User ID:", authContext.user.id)

  // Your endpoint logic here...
  return c.json({
    message: "Success!",
    user: authContext.user,
    timestamp: new Date().toISOString()
  })
}
```

#### Alternative Pattern: Using Hono Middleware

For simpler authentication, you can also use the middleware directly with Hono's middleware pattern:

```typescript
import { requireAuth } from "../lib/auth"

// In your main app setup (index.ts):
app.use('/protected/*', requireAuth())

// Then your endpoints under /protected/ will automatically be authenticated
```

#### Common Pitfalls to Avoid

❌ **Don't do this** (the bug we just fixed):
```typescript
// This is WRONG - it doesn't handle auth failures properly
try {
  await authMiddleware(c, async () => {})
} catch (error) {
  return c.json({ error: "Auth failed" }, 500)
}
// This will execute even if auth failed!
```

✅ **Do this instead**:
```typescript
// This is CORRECT - it properly handles auth failures
let authResult: Response | void
try {
  authResult = await authMiddleware(c, async () => {})
} catch (error) {
  return c.json({ error: "Authentication failed" }, 500)
}

if (authResult instanceof Response) {
  return authResult // Return the auth failure response
}
// Only continue if auth succeeded
```

### Environment Setup

Set the JWT secret in your Cloudflare Workers environment:

```bash
# For local development, add to .env:
JWT_SECRET=your-super-secret-key-here

# For production, set as a Cloudflare secret:
bun run wrangler secret put JWT_SECRET
```

### JWT Token Generation

Use the built-in CLI tool to generate tokens for development and testing:

```bash
# Interactive mode (prompts for all values)
bun run jwt --interactive

# Command line mode with environment variable
JWT_SECRET=your-local-secret bun run jwt --sub "user123" --expires "24h"

# Command line mode with explicit secret
bun run jwt --sub "admin" --secret "your-secret-here" --expires "1h"

# Using the local development secret
JWT_SECRET="$(cat .dev.vars | grep API_JWT_SECRET | cut -d'=' -f2 | tr -d '\"')" bun run jwt --sub "test-user"
```

**Important Notes:**
- The CLI tool **cannot** retrieve secrets from Cloudflare Workers (they're write-only for security)
- For local development, use the secret from `.dev.vars` or set `JWT_SECRET` environment variable
- For production use, generate tokens through your secure deployment environment
- Generated tokens are only valid with the same secret used by the API

### Testing Authentication

A test endpoint is available at `/auth/test` and `/api/auth/test` to verify authentication:

```bash
# Test without authentication (should fail with 401)
curl https://api.dave.io/auth/test # trunk-ignore(gitleaks/curl-auth-header)

# Test with invalid token (should fail with 401)
curl -H "Authorization: Bearer invalid-token" https://api.dave.io/auth/test

# Test with valid Bearer token (should succeed with 200)
curl -H "Authorization: Bearer YOUR_JWT_TOKEN" https://api.dave.io/auth/test # trunk-ignore(gitleaks/curl-auth-header)

# Test with query parameter (should succeed with 200)
curl "https://api.dave.io/auth/test?token=YOUR_JWT_TOKEN"
```

**Expected Responses:**
- Without token: `{"error":"Authentication required"}` (401)
- Invalid token: `{"error":"Invalid token"}` (401)
- Valid token: Success message with user info (200)

The auth test endpoint serves as both a testing tool and a reference implementation showing the correct authentication pattern. See `src/endpoints/auth-test.ts` for the complete implementation.

### Authentication Architecture Summary

The JWT authentication system consists of several key components:

1. **Middleware (`src/lib/auth.ts`)**:
   - `createJWTMiddleware()`: Creates the authentication middleware function
   - `requireAuth()`: Convenience function that returns the middleware
   - `extractTokenFromRequest()`: Extracts JWT from Authorization header or query param
   - `verifyJWT()`: Validates and decodes JWT tokens
   - `authorizeEndpoint()`: Creates a middleware that authorizes access based on JWT subject matching

2. **Type Definitions (`src/schemas/auth.schema.ts`)**:
   - `JWTPayload`: Interface for decoded JWT payload
   - `AuthorizedContext`: Extended Hono context with user info
   - `AuthError`: Standard error response format

3. **CLI Tool (`bin/jwt.ts`)**:
   - Interactive and command-line token generation
   - Supports custom expiration times and secrets
   - Helpful for development and testing

4. **Test Endpoint (`src/endpoints/auth-test.ts`)**:
   - Reference implementation of protected endpoint
   - Demonstrates correct middleware usage pattern
   - Available for testing authentication flow

### Endpoint-Specific Authorization

The API provides a convenient way to authorize access to specific endpoints and subresources based on the JWT subject using the `authorizeEndpoint()` function:

```typescript
import { authorizeEndpoint } from "../lib/auth"
import type { Context } from "hono"

export class MyEndpoint extends OpenAPIRoute {
  async handle(c: Context) {
    // Require JWT with subject 'users' or 'users:read'
    return authorizeEndpoint('users', 'read')(c, async () => {
      // This code only executes if authorized
      return c.json({ message: "Access granted to users endpoint" })
    })
  }
}
```

#### How It Works

1. The function takes two parameters:
   - `endpoint`: The main endpoint identifier (e.g., 'users', 'documents', 'ai')
   - `subresource` (optional): A specific subresource (e.g., 'read', 'write', 'alt-text')

2. JWT Authorization Rules:
   - If the JWT subject matches exactly the endpoint (e.g., "users", "ai"), it grants access to all subresources
   - If the JWT subject matches the specific pattern "endpoint:subresource" (e.g., "ai:alt-text"), it only grants access to that subresource

3. This allows for fine-grained permission control through JWT subjects:
   - Create tokens with endpoint access: `ai` grants access to all AI operations
   - Create tokens with specific permissions: `ai:alt-text` only grants access to the alt-text generation endpoint

4. Implementation pattern:
```typescript
// Protect an entire resource
app.get('/api/documents', authorizeEndpoint('documents'), (c) => {
  return c.json({ message: "All documents accessed" });
});

// Protect a specific subresource
app.get('/api/ai/alt-text', authorizeEndpoint('ai', 'alt-text'), (c) => {
  // Can now accept optional image query parameter
  return c.json({ message: "AI alt-text generation" });
});
```

5. Return Value Handling:
   - The function handles and returns the result of your callback function
   - Responses from your handler are passed through directly if authorization succeeds
   - Authentication failures return a 401 status with an error message
   - Authorization failures return a 403 status with an error message

#### Security Considerations

- The subject field in JWTs is cryptographically secured by the JWT signature
- Users cannot modify the subject without invalidating the token
- The middleware handles all authentication checks before authorization
- Proper error responses (401/403) are returned for unauthorized access

### Best Practices Recap

- ✅ **Always check middleware return value**: Don't assume it throws on failure
- ✅ **Use proper TypeScript types**: Leverage `AuthorizedContext` for type safety
- ✅ **Handle errors gracefully**: Provide clear error messages for different failure modes
- ✅ **Test thoroughly**: Verify both success and failure scenarios
- ✅ **Use environment variables**: Keep secrets out of code
- ❌ **Never ignore auth failures**: Always handle middleware responses properly
- ❌ **Don't hardcode secrets**: Use environment variables and Cloudflare secrets

### Key Components

1. **Endpoints**: Located in `src/endpoints/`

- Each endpoint is implemented as a class extending `OpenAPIRoute` from Chanfana
- Endpoints define their schema (for OpenAPI docs) and handling logic
- Each endpoint has a consistent structure:
  - `schema`: Defines the OpenAPI documentation and Zod validation schema
  - `handle(c: Context)`: Processes the request and returns a response

2. **KV Utilities**: Located in `src/kv/`

- Functionality for interacting with KV storage is abstracted into utility modules:
  - `dashboard.ts`: Handles dashboard-related KV operations
  - `redirect.ts`: Handles redirect-related KV operations
  - `routeros.ts`: Handles RouterOS-related KV operations
  - `metrics.ts`: Handles metrics tracking in KV
  - `init.ts`: Initializes KV storage with default values
- Each utility module provides a consistent interface for its domain:
  - Functions for retrieving data
  - Functions for storing data
  - Functions for metadata management

3. **Analytics & Metrics**: Located in `src/lib/` and `src/kv/`

- `analytics.ts`: Handles detailed request tracking via Analytics Engine
- `metrics.ts`: Manages error tracking and status code metrics in KV storage
- Each request is logged with detailed information:
  - Request details (path, method, timestamp)
  - Response details (status code, response time)
  - Client information (IP, user-agent, referrer)
- The `/metrics` endpoint exposes these metrics in multiple formats:
  - JSON format at `/metrics/json`
  - YAML format at `/metrics/yaml`
  - Prometheus format at `/metrics/prometheus`

4. **Cloudflare Integration**:

- KV Namespace: Single unified namespace (`DATA`) for all storage needs
- Analytics Engine: Tracks requests (`ANALYTICS`)
  - Each endpoint writes a data point with relevant information
  - Indexes are used for categorizing data points by endpoint type

5. **Command-line Utilities**: Located in `bin/`

- `kv.ts`: Backup and restore utility for KV data
- Run using Bun: `bun kv backup` or `bun kv restore <filename>`
- Provides data management and disaster recovery capabilities

## File Structure

- `src/` - Main source code
  - `endpoints/` - API endpoint implementations
  - `ping.ts` - Simple health check endpoint
  - `redirect.ts` - URL redirection service
  - `dashboard.ts` - Dashboard data feed endpoints
  - `routeros.ts` - RouterOS script generator endpoints
  - `metrics.ts` - Metrics endpoint for exposing KV metrics data
  - `kv/` - KV storage operations
  - `dashboard.ts` - KV storage operations for dashboard data
  - `redirect.ts` - KV storage operations for redirects
  - `routeros.ts` - KV storage operations for RouterOS data
  - `metrics.ts` - KV storage operations for metrics tracking
  - `init.ts` - KV initialization module
  - `lib/` - Utility libraries
  - `analytics.ts` - Request tracking via Analytics Engine
  - `auth.ts` - JWT authentication middleware and utilities
  - `ip-address-utils.ts` - IP address utilities
  - `schemas/` - Zod schema definitions
  - `redirect.schema.ts` - Schemas for redirect functionality
  - `dashboard.schema.ts` - Schemas for dashboard functionality
  - `ping.schema.ts` - Schemas for ping endpoint
  - `routeros.schema.ts` - Schemas for RouterOS functionality
  - `auth.schema.ts` - Schemas for authentication and JWT handling
  - `cloudflare.types.ts` - Type definitions for Cloudflare-specific objects
  - `index.ts` - Main application setup
  - `types.ts` - Type definitions
- `dashkit/` - Contains dashboard widget example
  - `feed.js` - Simple list panel implementation for dashboards
- `bin/` - Command-line utilities
  - `kv.ts` - KV backup and restore utility
  - `jwt.ts` - JWT token generation utility
- `wrangler.jsonc` - Cloudflare Workers configuration

## Development Environment Setup

- The project uses [Bun](https://bun.sh/) (v1.2.14 or compatible) as the package manager and runtime
- [mise](https://mise.jdx.dev/) is used for environment management (optional)
- Environment variables are loaded from `.env` file when mise is active

## KV Storage Architecture

The API uses a unified KV namespace (`DATA`) with a hierarchical key structure for all data storage needs. This approach provides clean organization and makes it easier to manage different types of data in a single namespace.

### KV Key Structure

The key structure follows the pattern `topic:subtopic:resource` to organize different types of data:

1. **Redirects**: Prefix `redirect:`

- `redirect:{slug}`: URL for the given redirect slug

2. **RouterOS**: Prefix `routeros:`

- `routeros:putio:ipv4`: Cached IPv4 ranges for put.io
- `routeros:putio:ipv6`: Cached IPv6 ranges for put.io
- `routeros:putio:script`: Generated RouterOS script for put.io
- `routeros:putio:metadata:last-updated`: Last update timestamp for put.io cache
- `routeros:putio:metadata:last-error`: Last error message for put.io cache
- `routeros:putio:metadata:last-attempt`: Last attempt timestamp for put.io cache
- `routeros:putio:metadata:update-in-progress`: Flag indicating if update is in progress

3. **Dashboard**: Prefix `dashboard:`

- `dashboard:demo:items`: Items for the demo dashboard

4. **Metrics**: Prefix `metrics:`

- `metrics:status:{code}`: Status code occurrence counter
- `metrics:group:{group}`: Status code group counter (4xx, 5xx)
- `metrics:routeros:cache-resets`: Count of cache resets
- `metrics:routeros:cache-hits`: Count of cache hits
- `metrics:routeros:cache-misses`: Count of cache misses
- `metrics:routeros:last-accessed`: Timestamp of last access
- `metrics:routeros:last-refresh`: Timestamp of last refresh
- `metrics:routeros:refresh-count`: Count of refreshes
- `metrics:routeros:last-reset`: Timestamp of last reset
- `metrics:routeros:reset-count`: Count of resets
- `metrics:redirect:{slug}:count`: Count of redirects for a slug
- `metrics:redirect:{slug}:last-accessed`: Timestamp of last access for a slug

### KV Utility Pattern

The code uses a consistent pattern for KV operations:

1. **Abstraction**: All KV operations are abstracted into dedicated modules in the `kv/` directory

- `kv/redirect.ts` handles redirect-related operations
- `kv/dashboard.ts` handles dashboard-related operations
- `kv/routeros.ts` handles RouterOS-related operations
- `kv/metrics.ts` handles metrics tracking
- `kv/init.ts` handles KV initialization

2. **Function Structure**: KV modules provide functions for:

- Retrieving data from KV
- Storing data in KV
- Managing metadata and statistics
- Error handling and logging

3. **Implementation**:

```typescript
// Example function pattern
export async function getData(
  env: { DATA: KVNamespace },
  key: string,
): Promise<T | null> {
  try {
    const data = await env.DATA.get<T>(`prefix:${key}`, { type: "json" });
    return data;
  } catch (error) {
    console.error("Error getting data for key", { key, error });
    return null;
  }
}
```

### Usage Pattern in Endpoints

Endpoints always interact with KV through these utility functions:

```typescript
// In endpoint handler
const redirect = await getRedirect(c.env, slug);

// Track usage
await trackRedirectClick(c.env, slug);
```

## Analytics Integration

The API uses Cloudflare Analytics Engine for comprehensive request tracking:

1. **Middleware Integration**:

- Captures request and response details
- Measures response time
- Logs client information

2. **Endpoint-Specific Tracking**:

- Each endpoint implements custom analytics tracking
- Uses appropriate indexes for categorization
- Records endpoint-specific information

Example from the redirect endpoint:

```typescript
c.env.ANALYTICS.writeDataPoint({
  blobs: ["redirect_request", slug],
  indexes: ["redirect"],
});
```

## Notes for Development

- The API is accessible at `api.dave.io` and `dave.io/api/*` when deployed
- Biome is used for code formatting and linting through Trunk
- CI/CD is implemented via GitHub Actions (`.github/workflows/`)
- For local development, the API runs on localhost with the port shown in the terminal when running `bun run dev`
- Always run `bun run typecheck` and `bun run lint` before submitting changes
- When adding new endpoints:
  1. Create a new file in `src/endpoints/`
  2. Implement a class extending `OpenAPIRoute` with schema and handle method
  3. Register the endpoint in `src/index.ts` using both direct and `/api/` prefixed paths
  4. Include appropriate analytics tracking using `c.env.ANALYTICS.writeDataPoint()`
- When adding new KV-backed functionality:
  1. Create a utility module in `src/kv/` for KV operations
  2. Follow the existing patterns for key structure and error handling
  3. Use the `DATA` KV namespace with appropriate key prefixes
  4. Update the `initializeKV()` function in `src/kv/init.ts` to handle new default values

## KV Admin Utility

The project includes a comprehensive KV admin utility in `bin/kv.ts` for managing KV data:

1. **Backup Functionality**:

- Backs up KV data to JSON files in the `_backup/` directory
- Selective backup with regex pattern matching for keys
- By default, backs up only dashboard demo items and redirects
- Can backup all keys with the `--all` flag

2. **Restore Capability**:

- Restores data from backup files
- Preserves value types (strings vs. JSON)
- Includes confirmation prompts for safety

3. **Data Wipe**:

- Complete KV namespace cleanup
- Multiple confirmation prompts to prevent accidents
- Detailed progress reporting

4. **Value Type Handling**:

- Intelligently handles different value types
- String values are stored without additional quotes
- JSON objects, arrays, and primitives are properly serialized

Usage:

```bash
bun kv backup             # Backup selected data
bun kv backup --all       # Backup all data
bun kv restore <file>     # Restore from backup
bun kv wipe               # Wipe all data (with confirmations)
```
