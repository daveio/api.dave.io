# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

api.dave.io is a multipurpose personal API powered by Cloudflare Workers. It provides several endpoints:

- **Ping**: Simple health check endpoint
- **Redirect**: URL redirection service using KV storage
- **Dashboard**: Data feeds for dashboards (demo and Hacker News available)
- **RouterOS**: Generates RouterOS scripts for network configurations (currently implements put.io IP ranges, with more providers planned)
- **Metrics**: View API metrics in JSON, YAML, or Prometheus format
- **Authentication**: Enterprise-grade JWT authentication system with usage tracking, request limits, and token revocation
- **Token Management**: Comprehensive token lifecycle management with CLI tools and API endpoints
- **AI**: AI-powered services including image alt text generation

The API is built with [Hono](https://hono.dev) and uses [Chanfana](https://github.com/cloudflare/chanfana) for OpenAPI documentation and schema validation.

## Development Commands

### Setup and Development

```bash
# Install dependencies
bun install

# Start development server
bun run dev

# Generate Cloudflare Workers type definitions
bun run types

# Deploy to Cloudflare Workers
bun run deploy

# Run TypeScript type checking
bun run typecheck

# Lint code with Trunk and Biome
bun run lint

# Format code with Trunk
bun run format

# Run KV backup/restore utility
bun kv backup           # Backup KV data matching patterns
bun kv backup --all     # Backup all KV data
bun kv restore <file>   # Restore KV data from backup
bun kv wipe             # Wipe all KV data (DANGEROUS!)

# Generate JWT tokens for authentication
bun run jwt --help                    # Show JWT generation help
bun run jwt create --interactive      # Interactive JWT generation
bun run jwt create --sub "ai:alt" --description "Alt text access" --expiry "30d"
bun run jwt list                      # List all tokens
bun run jwt show <uuid>               # Show token details
```

## Code Architecture

- **Framework**: Uses Hono.js for routing and HTTP server functionality
- **API Documentation**: Uses Chanfana (OpenAPI) for automatic documentation generation and schema validation
- **Type Safety**: Uses TypeScript and Zod for compile-time and runtime type validation
- **Schema Organization**: Comprehensive Zod schemas defined in `src/schemas/` directory for all endpoints
- **OpenAPI Integration**: Full OpenAPI 3.1 specification with interactive Swagger UI at `/docs`
- **KV Storage**: Uses a unified KV namespace with hierarchical keys for data organization
- **Analytics**: Uses Cloudflare Analytics Engine for request tracking

### Middleware Pipeline

The application uses a series of middleware to handle requests:

1. **KV Initialization**: Initializes KV with default values at startup
2. **Analytics Tracking**: Captures detailed request info for analytics
3. **Metrics Tracking**: Monitors non-success/non-redirect responses
4. **Endpoint Handlers**: Individual handlers for specific routes

### TypeScript Type Management

The project relies on Cloudflare Workers type definitions from the auto-generated `worker-configuration.d.ts` file. This approach ensures type definitions are always up-to-date with the current Wrangler configuration.

Key aspects of the type system:

1. **worker-configuration.d.ts**: Auto-generated by Wrangler (`bun run types`)

- Contains all Cloudflare Workers types (KVNamespace, etc.)
- Reference with `/// <reference path="../../worker-configuration.d.ts" />`

2. **src/schemas/cloudflare.types.ts**:

- Extends the auto-generated types with project-specific additions
- Adds custom environment bindings to the `Env` interface
- Provides type safety for Cloudflare bindings

3. **Type Checking**:

- Run `bun run typecheck` to verify type correctness
- Ensures proper usage of Cloudflare Workers types throughout the codebase

## JWT Authentication System

The API includes a comprehensive JWT-based authentication system with advanced features for enterprise-grade security and token management:

### Core Features

- **Enhanced JWT Token Structure**: Industry-standard tokens with UUID tracking, optional expiration, and request limits
- **Usage Tracking & Limits**: Track token usage in real-time with configurable request limits
- **Token Revocation**: Instantly revoke tokens for security incidents
- **Scope-Based Authorization**: Fine-grained permissions using hierarchical subjects
- **Multiple Token Sources**: Accepts tokens via `Authorization: Bearer` header or `?token=` query parameter
- **Comprehensive CLI Management**: Full token lifecycle management with security warnings
- **D1 Database Integration**: Production Cloudflare D1 database for persistent token metadata storage
- **KV Usage Tracking**: Real-time usage counting and metrics

### JWT Token Structure

Enhanced JWT tokens now include:

- **`jti` (JWT ID)**: Random UUID for unique identification and tracking
- **`sub` (Subject)**: Hierarchical permission identifier (e.g., `ai:alt`, `tokens:read`)
- **`exp` (Expiration)**: Optional expiration timestamp (defaults to 30 days)
- **`maxRequests`**: Optional request limit for finite-use tokens
- **`iat` (Issued At)**: Token creation timestamp

Example JWT payload:
```json
{
  "sub": "ai:alt",
  "iat": 1748375490,
  "jti": "de346b19-9fac-4309-9a9a-ca49b8cc82a6",
  "exp": 1750967490,
  "maxRequests": 1000
}
```

### Token Security & Lifecycle

**Default Security Settings:**
- **30-day expiration by default** for enhanced security
- UUID-based tracking prevents token confusion
- Cryptographically signed and tamper-proof
- Request counting prevents abuse

**Revocation System:**
- Instant token revocation via KV storage (`auth:revocation:${UUID}`)
- Graceful degradation - revoked tokens receive 401 responses
- Revocation status checked on every request

**Usage Tracking:**
- Request counting stored in KV (`auth:count:${UUID}`)
- Automatic increment on successful authentication
- Detailed metrics by UUID for monitoring

### Authentication Middleware

The enhanced authentication middleware now performs comprehensive validation:

```typescript
// The middleware now handles:
// 1. JWT signature verification
// 2. Expiration checking (if present)
// 3. UUID validation
// 4. Revocation status check
// 5. Request limit enforcement
// 6. Usage counting
// 7. Metrics tracking

import { requireAuth, authorizeEndpoint } from "../lib/auth"

// Basic authentication
const authResult = await requireAuth()(c, async () => {
  // Authenticated code here
})

// Endpoint-specific authorization
return authorizeEndpoint("ai", "alt")(c, async () => {
  // Code for AI alt text generation
})
```

### Token Management API

New API endpoints for token administration:

#### Get Token Usage Information
```http
GET /tokens/:uuid/usage
Authorization: Bearer <admin-token-with-tokens:read>
```

Response:
```json
{
  "uuid": "de346b19-9fac-4309-9a9a-ca49b8cc82a6",
  "requestCount": 42,
  "lastUsed": "2024-01-01T12:00:00.000Z",
  "isRevoked": false
}
```

#### Revoke/Unrevoke Token
```http
POST /tokens/:uuid/revoke
Authorization: Bearer <admin-token-with-tokens:write>
Content-Type: application/json

{
  "revoked": true
}
```

Response:
```json
{
  "uuid": "de346b19-9fac-4309-9a9a-ca49b8cc82a6",
  "revoked": true,
  "message": "Token revoked successfully"
}
```

### Using Authentication in Endpoints

To protect an endpoint, apply the `requireAuth()` middleware. **Important**: The middleware returns a Response object when authentication fails, so you must check for and handle this properly:

```typescript
import { requireAuth, type AuthorizedContext } from "../lib/auth"
import type { Context } from "hono"

// In your endpoint's handle method:
async handle(c: Context) {
  // Create the authentication middleware
  const authMiddleware = requireAuth()

  // The middleware will return a Response if authentication fails
  // We need to capture and check the result
  let authResult: Response | void

  try {
    authResult = await authMiddleware(c, async () => {
      // This empty function will only be called if auth succeeds
    })
  } catch (error) {
    console.error("Auth middleware error:", error)
    return c.json({ error: "Authentication failed" }, 500)
  }

  // If the middleware returned a Response, it means auth failed
  if (authResult instanceof Response) {
    return authResult
  }

  // If we get here, authentication succeeded
  const authContext = c as AuthorizedContext
  console.log("User ID:", authContext.user.id)

  // Your endpoint logic here...
  return c.json({
    message: "Success!",
    user: authContext.user,
    timestamp: new Date().toISOString()
  })
}
```

#### Alternative Pattern: Using Hono Middleware

For simpler authentication, you can also use the middleware directly with Hono's middleware pattern:

```typescript
import { requireAuth } from "../lib/auth"

// In your main app setup (index.ts):
app.use('/protected/*', requireAuth())

// Then your endpoints under /protected/ will automatically be authenticated
```

#### Common Pitfalls to Avoid

❌ **Don't do this** (the bug we just fixed):
```typescript
// This is WRONG - it doesn't handle auth failures properly
try {
  await authMiddleware(c, async () => {})
} catch (error) {
  return c.json({ error: "Auth failed" }, 500)
}
// This will execute even if auth failed!
```

✅ **Do this instead**:
```typescript
// This is CORRECT - it properly handles auth failures
let authResult: Response | void
try {
  authResult = await authMiddleware(c, async () => {})
} catch (error) {
  return c.json({ error: "Authentication failed" }, 500)
}

if (authResult instanceof Response) {
  return authResult // Return the auth failure response
}
// Only continue if auth succeeded
```

### Environment Setup

Set the JWT secret in your Cloudflare Workers environment:

```bash
# For local development, add to .env:
API_JWT_SECRET=your-super-secret-key-here

# For production, set as a Cloudflare secret:
bun run wrangler secret put API_JWT_SECRET
```

### JWT Token Management CLI

The enhanced CLI tool provides comprehensive token lifecycle management with enterprise-grade security features:

#### Creating Tokens

**Basic Token Creation (30-day default expiry):**
```bash
# Standard token with 30-day expiration (default)
bun jwt create --sub "ai:alt" --description "Alt text generation for Dave"

# Token with custom expiration
bun jwt create --sub "ai" --expiry "7d" --max-requests 1000 --description "AI endpoints access"

# Token with request limits but no expiration
bun jwt create --sub "metrics" --max-requests 500 --description "Limited metrics access"
```

**No-Expiry Tokens (Advanced):**
```bash
# Token without expiration (requires confirmation - NOT RECOMMENDED)
bun jwt create --sub "admin" --no-expiry --description "Emergency admin access"

# Skip confirmation for no-expiry (use with extreme caution)
bun jwt create --sub "system" --no-expiry --seriously-no-expiry --description "System service token"
```

**Interactive Mode:**
```bash
# Guided token creation with prompts
bun jwt create --interactive

# Interactive mode with secret
bun jwt create --interactive --secret "your-secret-here"
```

#### Managing Existing Tokens

**List All Tokens:**
```bash
# List all stored tokens with status
bun jwt list

# Limit results
bun jwt list --limit 10
```

**Search Tokens:**
```bash
# Search by subject
bun jwt search --sub "ai"

# Search by description
bun jwt search --description "Dave"

# Find specific token
bun jwt search --uuid "de346b19-9fac-4309-9a9a-ca49b8cc82a6"
```

**Token Details:**
```bash
# Show detailed information about a token
bun jwt show de346b19-9fac-4309-9a9a-ca49b8cc82a6
```

**Token Revocation:**
```bash
# Get revocation instructions (requires KV/API access)
bun jwt revoke de346b19-9fac-4309-9a9a-ca49b8cc82a6
```

#### Security Features

**Default Security Settings:**
- **30-day expiration by default** - tokens automatically expire for security
- **Confirmation required for no-expiry** - prevents accidental permanent tokens
- **Warning messages** - clear security guidance for dangerous operations

**Environment Variables:**
```bash
# JWT secret (required)
export API_JWT_SECRET="your-secret-key"
```

**Database Requirements:**
The CLI uses the production Cloudflare D1 database (`API_AUTH_METADATA`) via the Cloudflare SDK:

```bash
# Required environment variables:
export CLOUDFLARE_API_TOKEN=your-cloudflare-api-token-with-d1-permissions
export CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
export CLOUDFLARE_D1_DATABASE_ID=your-api-auth-metadata-database-id
export API_JWT_SECRET=your-jwt-secret

# The CLI will automatically initialize the database schema on first use
# All token metadata is stored in production D1, not locally
```

**Important Notes:**
- **Always uses production D1** - no local database simulation or Wrangler CLI dependency
- **Uses Cloudflare SDK directly** - leverages the official TypeScript SDK for D1 operations
- **Automatic schema initialization** - creates tables if they don't exist
- **Requires API token with D1 permissions** - must have read/write access to D1 database
- **Persistent across environments** - token metadata survives local changes
- **Database name changed** - now uses `API_AUTH_METADATA` instead of `auth_tokens`

**CLI Security Examples:**
```bash
# Safe: Standard token with default 30-day expiry
bun jwt create --sub "api:read" --description "Standard API access"

# Caution: Long-lived but expiring token
bun jwt create --sub "ci:deploy" --expiry "1y" --description "CI deployment token"

# Dangerous: No expiry requires explicit confirmation
bun jwt create --sub "emergency" --no-expiry --description "Emergency access"
⚠️  WARNING: You are creating a token without expiration!
   This is NOT RECOMMENDED for security reasons.
   Tokens without expiration remain valid indefinitely unless explicitly revoked.
   Consider using a long expiration period instead (e.g., --expiry '1y').

Are you sure you want to create a token without expiration? [y/n]: n
❌ Token creation cancelled

# Override confirmation (use with extreme caution)
bun jwt create --sub "system" --no-expiry --seriously-no-expiry
```

**Important Security Notes:**
- **Tokens default to 30-day expiration** for enhanced security
- **No-expiry tokens require explicit confirmation** to prevent accidental creation
- **Use `--seriously-no-expiry` sparingly** - only for automated systems
- **Store JWT secrets securely** - never commit them to version control
- **The CLI cannot retrieve Cloudflare secrets** (they're write-only for security)
- **Generated tokens are only valid with the same secret** used by the API

### Testing Authentication

A test endpoint is available at `/auth` and `/api/auth` to verify authentication and get detailed JWT information:

```bash
# Test without authentication (should fail with 401)
curl https://api.dave.io/auth # trunk-ignore(gitleaks/curl-auth-header)

# Test with invalid token (should fail with 401)
curl -H "Authorization: Bearer invalid-token" https://api.dave.io/auth

# Test with valid Bearer token (should succeed with 200)
curl -H "Authorization: Bearer YOUR_JWT_TOKEN" https://api.dave.io/auth # trunk-ignore(gitleaks/curl-auth-header)

# Test with query parameter (should succeed with 200)
curl "https://api.dave.io/auth?token=YOUR_JWT_TOKEN"
```

**Expected Responses:**
- Without token: `{"error":"Authentication required"}` (401)
- Invalid token: `{"error":"Invalid token"}` (401)
- Valid token: Success message with detailed JWT information (200)

**Success Response Example:**
```json
{
  "message": "Authentication successful! JWT details retrieved.",
  "jwt": {
    "subject": "ai:alt",
    "subjectParts": ["ai", "alt"],
    "issuedAt": 1640995200,
    "expiresAt": 1641081600,
    "timeToExpiry": 86400,
    "isExpired": false
  },
  "user": {
    "id": "ai:alt"
  },
  "timestamp": "2024-01-01T12:00:00.000Z"
}
```

The auth endpoint now accepts any valid JWT subject and returns comprehensive information about the token, including the subject split by colons (showing the hierarchical structure we use for permissions). See `src/endpoints/auth.ts` for the complete implementation.

### Authentication Architecture Summary

The JWT authentication system consists of several key components:

1. **Middleware (`src/lib/auth.ts`)**:
   - `createJWTMiddleware()`: Creates the authentication middleware function
   - `requireAuth()`: Convenience function that returns the middleware
   - `extractTokenFromRequest()`: Extracts JWT from Authorization header or query param
   - `verifyJWT()`: Validates and decodes JWT tokens
   - `authorizeEndpoint()`: Creates a middleware that authorizes access based on JWT subject matching

2. **Type Definitions (`src/schemas/auth.schema.ts`)**:
   - `JWTPayload`: Interface for decoded JWT payload
   - `AuthorizedContext`: Extended Hono context with user info
   - `AuthError`: Standard error response format

3. **CLI Tool (`bin/jwt.ts`)**:
   - Interactive and command-line token generation
   - Supports custom expiration times and secrets
   - Helpful for development and testing

4. **Test Endpoint (`src/endpoints/auth.ts`)**:
   - Reference implementation of protected endpoint
   - Demonstrates correct middleware usage pattern
   - Available for testing authentication flow

### Endpoint-Specific Authorization

The API provides a convenient way to authorize access to specific endpoints and subresources based on the JWT subject using the `authorizeEndpoint()` function:

```typescript
import { authorizeEndpoint } from "../lib/auth"
import type { Context } from "hono"

export class MyEndpoint extends OpenAPIRoute {
  async handle(c: Context) {
    // Require JWT with subject 'users' or 'users:read'
    return authorizeEndpoint('users', 'read')(c, async () => {
      // This code only executes if authorized
      return c.json({ message: "Access granted to users endpoint" })
    })
  }
}
```

#### How It Works

1. The function takes two parameters:
   - `endpoint`: The main endpoint identifier (e.g., 'users', 'documents', 'ai')
   - `subresource` (optional): A specific subresource (e.g., 'read', 'write', 'alt')

2. JWT Authorization Rules:
   - If the JWT subject matches exactly the endpoint (e.g., "users", "ai"), it grants access to all subresources
   - If the JWT subject matches the specific pattern "endpoint:subresource" (e.g., "ai:alt"), it only grants access to that subresource

3. This allows for fine-grained permission control through JWT subjects:
   - Create tokens with endpoint access: `ai` grants access to all AI operations
   - Create tokens with specific permissions: `ai:alt` only grants access to the alt text generation endpoint

4. Implementation pattern:
```typescript
// Protect an entire resource
app.get('/api/documents', authorizeEndpoint('documents'), (c) => {
  return c.json({ message: "All documents accessed" });
});

// Protect a specific subresource
app.get('/api/ai/alt', authorizeEndpoint('ai', 'alt'), (c) => {
  // Process image URL for alt text generation
  return c.json({ message: "AI alt text generation via URL" });
});

// Protect POST endpoint with same authorization pattern
app.post('/api/ai/alt', authorizeEndpoint('ai', 'alt'), (c) => {
  // Process uploaded base64 image data for alt text generation
  return c.json({ message: "AI alt text generation for uploaded image" });
});
```

5. Return Value Handling:
   - The function handles and returns the result of your callback function
   - Responses from your handler are passed through directly if authorization succeeds
   - Authentication failures return a 401 status with an error message
   - Authorization failures return a 403 status with an error message

#### Security Considerations

- The subject field in JWTs is cryptographically secured by the JWT signature
- Users cannot modify the subject without invalidating the token
- The middleware handles all authentication checks before authorization
- Proper error responses (401/403) are returned for unauthorized access

### Best Practices Recap

- ✅ **Always check middleware return value**: Don't assume it throws on failure
- ✅ **Use proper TypeScript types**: Leverage `AuthorizedContext` for type safety
- ✅ **Handle errors gracefully**: Provide clear error messages for different failure modes
- ✅ **Test thoroughly**: Verify both success and failure scenarios
- ✅ **Use environment variables**: Keep secrets out of code
- ❌ **Never ignore auth failures**: Always handle middleware responses properly
- ❌ **Don't hardcode secrets**: Use environment variables and Cloudflare secrets

### Key Components

1. **Endpoints**: Located in `src/endpoints/`

- Each endpoint is implemented as a class extending `OpenAPIRoute` from Chanfana
- Endpoints define their schema (for OpenAPI docs) and handling logic
- Each endpoint has a consistent structure:
  - `schema`: Defines the OpenAPI documentation and Zod validation schema
  - `handle(c: Context)`: Processes the request and returns a response

2. **KV Utilities**: Located in `src/kv/`

- Functionality for interacting with KV storage is abstracted into utility modules:
  - `dashboard.ts`: Handles dashboard-related KV operations
  - `redirect.ts`: Handles redirect-related KV operations
  - `routeros.ts`: Handles RouterOS-related KV operations
  - `metrics.ts`: Handles metrics tracking in KV
  - `init.ts`: Initializes KV storage with default values
- Each utility module provides a consistent interface for its domain:
  - Functions for retrieving data
  - Functions for storing data
  - Functions for metadata management

3. **Analytics & Metrics**: Located in `src/lib/` and `src/kv/`

- `analytics.ts`: Handles detailed request tracking via Analytics Engine
- `metrics.ts`: Manages error tracking and status code metrics in KV storage
- Each request is logged with detailed information:
  - Request details (path, method, timestamp)
  - Response details (status code, response time)
  - Client information (IP, user-agent, referrer)
- The `/metrics` endpoint exposes these metrics in multiple formats:
  - JSON format at `/metrics/json`
  - YAML format at `/metrics/yaml`
  - Prometheus format at `/metrics/prometheus`

4. **Cloudflare Integration**:

- KV Namespace: Single unified namespace (`DATA`) for all storage needs
- Analytics Engine: Tracks requests (`ANALYTICS`)
  - Each endpoint writes a data point with relevant information
  - Indexes are used for categorizing data points by endpoint type

5. **Command-line Utilities**: Located in `bin/`

- `kv.ts`: Backup and restore utility for KV data
- Run using Bun: `bun kv backup` or `bun kv restore <filename>`
- Provides data management and disaster recovery capabilities

## File Structure

- `src/` - Main source code
  - `endpoints/` - API endpoint implementations
  - `ping.ts` - Simple health check endpoint
  - `redirect.ts` - URL redirection service
  - `dashboard.ts` - Dashboard data feed endpoints
  - `routeros.ts` - RouterOS script generator endpoints
  - `metrics.ts` - Metrics endpoint for exposing KV metrics data
  - `kv/` - KV storage operations
  - `dashboard.ts` - KV storage operations for dashboard data
  - `redirect.ts` - KV storage operations for redirects
  - `routeros.ts` - KV storage operations for RouterOS data
  - `metrics.ts` - KV storage operations for metrics tracking
  - `init.ts` - KV initialization module
  - `lib/` - Utility libraries
  - `analytics.ts` - Request tracking via Analytics Engine
  - `auth.ts` - JWT authentication middleware and utilities
  - `ip-address-utils.ts` - IP address utilities
  - `schemas/` - Zod schema definitions
  - `redirect.schema.ts` - Schemas for redirect functionality
  - `dashboard.schema.ts` - Schemas for dashboard functionality
  - `ping.schema.ts` - Schemas for ping endpoint
  - `routeros.schema.ts` - Schemas for RouterOS functionality
  - `auth.schema.ts` - Schemas for authentication and JWT handling
  - `cloudflare.types.ts` - Type definitions for Cloudflare-specific objects
  - `index.ts` - Main application setup
  - `types.ts` - Type definitions
- `dashkit/` - Contains dashboard widget example
  - `feed.js` - Simple list panel implementation for dashboards
- `bin/` - Command-line utilities
  - `kv.ts` - KV backup and restore utility
  - `jwt.ts` - JWT token generation utility
- `wrangler.jsonc` - Cloudflare Workers configuration

## Development Environment Setup

- The project uses [Bun](https://bun.sh/) (v1.2.14 or compatible) as the package manager and runtime
- [mise](https://mise.jdx.dev/) is used for environment management (optional)
- Environment variables are loaded from `.env` file when mise is active

## KV Storage Architecture

The API uses a unified KV namespace (`DATA`) with a hierarchical key structure for all data storage needs. This approach provides clean organization and makes it easier to manage different types of data in a single namespace.

### KV Key Structure

The key structure follows the pattern `topic:subtopic:resource` to organize different types of data:

1. **Redirects**: Prefix `redirect:`

- `redirect:{slug}`: URL for the given redirect slug

2. **RouterOS**: Prefix `routeros:`

- `routeros:putio:ipv4`: Cached IPv4 ranges for put.io
- `routeros:putio:ipv6`: Cached IPv6 ranges for put.io
- `routeros:putio:script`: Generated RouterOS script for put.io
- `routeros:putio:metadata:last-updated`: Last update timestamp for put.io cache
- `routeros:putio:metadata:last-error`: Last error message for put.io cache
- `routeros:putio:metadata:last-attempt`: Last attempt timestamp for put.io cache
- `routeros:putio:metadata:update-in-progress`: Flag indicating if update is in progress

3. **Dashboard**: Prefix `dashboard:`

- `dashboard:demo:items`: Items for the demo dashboard

4. **Metrics**: Prefix `metrics:`

- `metrics:status:{code}`: Status code occurrence counter
- `metrics:group:{group}`: Status code group counter (4xx, 5xx)
- `metrics:routeros:cache-resets`: Count of cache resets
- `metrics:routeros:cache-hits`: Count of cache hits
- `metrics:routeros:cache-misses`: Count of cache misses
- `metrics:routeros:last-accessed`: Timestamp of last access
- `metrics:routeros:last-refresh`: Timestamp of last refresh
- `metrics:routeros:refresh-count`: Count of refreshes
- `metrics:routeros:last-reset`: Timestamp of last reset
- `metrics:routeros:reset-count`: Count of resets
- `metrics:redirect:{slug}:count`: Count of redirects for a slug
- `metrics:redirect:{slug}:last-accessed`: Timestamp of last access for a slug
- `metrics:auth:{uuid}:{event}`: JWT token event tracking (successful_auth, limit_exceeded, revoked_access_attempt)

5. **Authentication**: Prefix `auth:`

- `auth:count:{uuid}:requests`: Token request count (integer)
- `auth:count:{uuid}:last-used`: Token last used timestamp (ISO string)
- `auth:revocation:{uuid}`: Token revocation status (true/false)

### KV Utility Pattern

The code uses a consistent pattern for KV operations:

1. **Abstraction**: All KV operations are abstracted into dedicated modules in the `kv/` directory

- `kv/redirect.ts` handles redirect-related operations
- `kv/dashboard.ts` handles dashboard-related operations
- `kv/routeros.ts` handles RouterOS-related operations
- `kv/metrics.ts` handles metrics tracking
- `kv/auth.ts` handles JWT authentication tracking and revocation
- `kv/init.ts` handles KV initialization

2. **Function Structure**: KV modules provide functions for:

- Retrieving data from KV
- Storing data in KV
- Managing metadata and statistics
- Error handling and logging

3. **Implementation**:

```typescript
// Example function pattern
export async function getData(
  env: { DATA: KVNamespace },
  key: string,
): Promise<T | null> {
  try {
    const data = await env.DATA.get<T>(`prefix:${key}`, { type: "json" });
    return data;
  } catch (error) {
    console.error("Error getting data for key", { key, error });
    return null;
  }
}
```

### Usage Pattern in Endpoints

Endpoints always interact with KV through these utility functions:

```typescript
// In endpoint handler
const redirect = await getRedirect(c.env, slug);

// Track usage
await trackRedirectClick(c.env, slug);
```

## Analytics Integration

The API uses Cloudflare Analytics Engine for comprehensive request tracking:

1. **Middleware Integration**:

- Captures request and response details
- Measures response time
- Logs client information

2. **Endpoint-Specific Tracking**:

- Each endpoint implements custom analytics tracking
- Uses appropriate indexes for categorization
- Records endpoint-specific information

Example from the redirect endpoint:

```typescript
c.env.ANALYTICS.writeDataPoint({
  blobs: ["redirect_request", slug],
  indexes: ["redirect"],
});
```

## AI Endpoints

### AI Alt Text Generation

The API provides endpoints for generating descriptive alt text for images using Cloudflare AI. These endpoints use the LLaVA model (`@cf/llava-hf/llava-1.5-7b-hf`) for high-quality image understanding and description generation.

#### Endpoint Paths

- **GET** `/ai/alt` or `/api/ai/alt`: Generate alt text from an image URL
- **POST** `/ai/alt` or `/api/ai/alt`: Generate alt text from uploaded image data

#### Authentication Requirements

- **Required**: Valid JWT token with `ai` or `ai:alt` subject
- **Token Sources**:
  - Header: `Authorization: Bearer <token>`
  - Query parameter: `?token=<token>`

#### GET Method (Image URL)

**Parameters:**
- `image` (query parameter): URL of the image to generate alt text for

**Supported Image Formats:** JPG, JPEG, PNG, GIF, WebP, BMP, SVG
**Maximum Image Size:** 4MB

**Example Request:**
```bash
curl -H "Authorization: Bearer <TOKEN>" \
  "https://api.dave.io/ai/alt?image=https://example.com/image.jpg"
```

#### POST Method (Direct Upload)

**Request Body:**
```json
{
  "image": "data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA..."
}
```

**Example Request:**
```bash
curl -X POST \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"image":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA..."}' \
  https://api.dave.io/ai/alt
```

#### Features

- Uses Cloudflare's LLaVA model (`@cf/llava-hf/llava-1.5-7b-hf`) for high-quality image understanding
- Supports both URL-based image processing and direct base64 image uploads
- Comprehensive rate limiting (100 requests per hour per user)
- Input validation for image formats (JPG, JPEG, PNG, GIF, WebP, BMP, SVG)
- File size limits (4MB maximum)
- Detailed error responses with specific error codes for troubleshooting
- Real-time rate limit information in all responses

#### Request/Response Format

**GET Request:**
```bash
curl -H "Authorization: Bearer <TOKEN>" \
  "https://api.dave.io/ai/alt?image=https://example.com/photo.jpg"
```

**POST Request:**
```bash
curl -X POST \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"image":"data:image/jpeg;base64,/9j/4AAQSkZJRgABAQEA..."}' \
  https://api.dave.io/ai/alt
```

**Success Response (200):**
```json
{
  "altText": "A beautiful sunset over the ocean with orange and pink clouds",
  "image": "https://example.com/photo.jpg",
  "timestamp": "2024-01-01T12:00:00.000Z",
  "rateLimit": {
    "remaining": 99,
    "reset": "2024-01-01T13:00:00.000Z",
    "limit": 100
  }
}
```

**Error Response Examples:**
```json
// Invalid image URL (400)
{
  "error": "Invalid image URL - URL must point to a valid image file",
  "code": "INVALID_IMAGE_URL"
}

// Rate limit exceeded (429)
{
  "error": "Rate limit exceeded",
  "code": "RATE_LIMIT_EXCEEDED",
  "rateLimit": {
    "remaining": 0,
    "reset": "2024-01-01T13:00:00.000Z",
    "limit": 100
  }
}
```

#### Authentication

Create a JWT token with the required subject:

```bash
# Generate a token with access to all AI endpoints
bun jwt --sub "ai" --expiry "24h"

# Generate a token with access only to alt text generation
bun jwt --sub "ai:alt" --expiry "24h"

# Interactive token generation with custom options
bun jwt --interactive
```

#### Error Codes

The AI endpoints return specific error codes for different failure scenarios:

- `INVALID_IMAGE_URL`: The provided URL doesn't point to a valid image file
- `INVALID_URL_FORMAT`: The image URL format is malformed
- `FETCH_ERROR`: Failed to fetch the image from the provided URL
- `INVALID_CONTENT_TYPE`: The URL doesn't point to an image resource
- `IMAGE_TOO_LARGE`: The image exceeds the 4MB size limit
- `NO_IMAGE_PROVIDED`: No image URL or data was provided in the request
- `INVALID_IMAGE_DATA`: Invalid base64 image data format (POST requests)
- `INVALID_IMAGE_FORMAT`: Malformed image data structure
- `INVALID_BASE64`: Invalid base64 encoding
- `AI_PROCESSING_ERROR`: The AI model failed to process the image
- `RATE_LIMIT_EXCEEDED`: The user has exceeded their hourly request limit

## Notes for Development

- The API is accessible at `api.dave.io` and `dave.io/api/*` when deployed
- Biome is used for code formatting and linting through Trunk
- CI/CD is implemented via GitHub Actions (`.github/workflows/`)
- For local development, the API runs on localhost with the port shown in the terminal when running `bun run dev`
- Always run `bun run typecheck` and `bun run lint` before submitting changes
- When adding new endpoints:
  1. Create a new file in `src/endpoints/`
  2. Implement a class extending `OpenAPIRoute` with schema and handle method
  3. Register the endpoint in `src/index.ts` using both direct and `/api/` prefixed paths
  4. Include appropriate analytics tracking using `c.env.ANALYTICS.writeDataPoint()`
- When adding new KV-backed functionality:
  1. Create a utility module in `src/kv/` for KV operations
  2. Follow the existing patterns for key structure and error handling
  3. Use the `DATA` KV namespace with appropriate key prefixes
  4. Update the `initializeKV()` function in `src/kv/init.ts` to handle new default values

## KV Admin Utility

The project includes a comprehensive KV admin utility in `bin/kv.ts` for managing KV data via the Cloudflare SDK:

### Environment Requirements

```bash
# Required environment variables
export CLOUDFLARE_API_TOKEN=your-cloudflare-api-token
export CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
```

### KV Utility Features

1. **Backup Functionality**:

- Backs up KV data to JSON files in the `_backup/` directory
- Uses Cloudflare SDK directly (no Wrangler CLI dependency)
- Selective backup with regex pattern matching for keys
- By default, backs up only dashboard demo items and redirects
- Can backup all keys with the `--all` flag

2. **Restore Capability**:

- Restores data from backup files using SDK
- Preserves value types (strings vs. JSON)
- Includes confirmation prompts for safety

3. **Data Wipe**:

- Complete KV namespace cleanup via SDK
- Multiple confirmation prompts to prevent accidents
- Detailed progress reporting

4. **Value Type Handling**:

- Intelligently handles different value types
- String values are stored without additional quotes
- JSON objects, arrays, and primitives are properly serialized

### Usage

```bash
bun kv backup             # Backup selected data
bun kv backup --all       # Backup all data
bun kv restore <file>     # Restore from backup
bun kv wipe               # Wipe all data (with confirmations)
```

### SDK Integration

The utility uses the official Cloudflare TypeScript SDK for all operations:
- `cloudflare.kv.namespaces.keys.list()` for key enumeration
- `cloudflare.kv.namespaces.values.get()` for value retrieval
- `cloudflare.kv.namespaces.values.update()` for value storage
- `cloudflare.kv.namespaces.values.delete()` for key deletion
