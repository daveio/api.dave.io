# CLAUDE.md

This file provides comprehensive guidance to Claude Code and other AI agents when working with the dave.io codebase.

## Project Overview

dave.io is a unified multipurpose platform built on Cloudflare Workers that seamlessly combines a Vue.js single-page application with a comprehensive Hono-based API backend. The project demonstrates modern serverless architecture patterns and serves as both a personal website and a sophisticated API platform.

**Architecture Highlights:**

- **Unified Deployment**: Single Cloudflare Workers instance serving both frontend and backend
- **Type-Safe Development**: Full TypeScript with Zod schema validation throughout
- **Enterprise Authentication**: JWT-based auth with revocation, usage tracking, and hierarchical permissions
- **Modern Frontend**: Vue 3 SPA with Composition API, auto-imports, and advanced tooling
- **Comprehensive Observability**: Multi-format metrics, detailed analytics, and error tracking
- **Developer-First CLI Tools**: Sophisticated utilities for token management and data administration

## Development Environment

**Package Manager**: Bun (v1.2.15) - used for all package management, script execution, and development tasks
**Runtime**: Cloudflare Workers with Node.js compatibility enabled
**Environment Management**: mise (optional) for environment variable loading

### Required Environment Variables

For local development, create a `.env` file:

```bash
# JWT Authentication (required for token operations)
API_JWT_SECRET=your-super-secret-key-here

# Cloudflare API access for CLI tools (optional for basic development)
CLOUDFLARE_API_TOKEN=your-cloudflare-api-token
CLOUDFLARE_ACCOUNT_ID=your-cloudflare-account-id
CLOUDFLARE_D1_DATABASE_ID=your-d1-database-id  # For JWT token metadata
```

### Development Commands

**Primary Development Workflow:**

```bash
# Install dependencies
bun install

# Start unified development server (RECOMMENDED)
bun run dev                 # Frontend + API together with hot reload

# Individual development modes
bun run dev-frontend        # Vue.js only with hot reload
bun run dev-worker          # Worker API only with hot reload

# Type checking and linting
bun run typecheck          # Full TypeScript validation (frontend + backend)
bun run lint               # Biome + Trunk linting
bun run format             # Code formatting

# Build and deployment
bun run build              # Complete build: types + frontend + worker
bun run deploy             # Build and deploy to Cloudflare
bun run clean              # Remove all generated files

# CLI utilities
bun run jwt --help         # JWT token management
bun run kv --help          # KV data backup/restore
```

### Type System Integration

The project uses Cloudflare Workers auto-generated types with custom extensions:

1. **worker-configuration.d.ts**: Auto-generated by `bun run types` from Wrangler config
2. **src/schemas/**: Zod schemas for runtime validation and OpenAPI documentation
3. **Type References**: Use `/// <reference path="../worker-configuration.d.ts" />` in source files

## Code Architecture

### Request Flow Pipeline

Requests flow through a sophisticated middleware chain in `src/index.ts`:

```typescript
// 1. Static Redirects - Handle hardcoded redirects (/cv, /contact, etc.)
// 2. Headers Middleware - Add CORS headers for .well-known/nostr.json
// 3. Shell Script Detection - Serve shell scripts to curl/wget at root
// 4. KV Initialization - Ensure KV storage has default values
// 5. Analytics Tracking - Comprehensive request/response analytics
// 6. Metrics Tracking - Error and status code tracking
// 7. Endpoint Routing - API endpoints and Go redirects
// 8. Static Asset Fallback - Serve Vue.js SPA for unmatched routes
```

### Endpoint Architecture

All API endpoints follow the **Chanfana OpenAPIRoute pattern** with consistent structure:

```typescript
export class MyEndpoint extends OpenAPIRoute {
  schema = {
    tags: ["Category"],
    summary: "Endpoint description",
    request: {
      params: z.object({ id: z.string() }),
      query: z.object({ filter: z.string().optional() })
    },
    responses: {
      "200": { description: "Success", content: { "application/json": { schema: MyResponseSchema } } }
    }
  }

  async handle(c: Context) {
    // 1. Extract and validate request data
    // 2. Perform authentication if required
    // 3. Execute business logic
    // 4. Track analytics/metrics
    // 5. Return typed response
  }
}
```

### API Endpoints Reference

**Core Services:**

- `GET /api/ping` - Health check with system status
- `GET /go/:slug` - URL redirection service (outside /api/ for clean URLs)
- `GET /api/dashboard/:name` - Dashboard data feeds (demo, hackernews)
- `GET /api/routeros/putio` - RouterOS script generation for put.io IP ranges
- `GET /api/routeros/cache` - RouterOS cache status and statistics
- `GET /api/routeros/reset` - Reset RouterOS cache
- `GET /api/metrics[/format]` - System metrics (JSON/YAML/Prometheus)

**Authentication & Token Management:**

- `GET /api/auth` - JWT authentication testing and token validation
- `GET /api/tokens/:uuid/usage` - Token usage statistics and limits
- `POST /api/tokens/:uuid/revoke` - Token revocation management

**AI Services:**

- `GET /api/ai/alt?image=url` - Generate alt text from image URL
- `POST /api/ai/alt` - Generate alt text from uploaded base64 image data

### KV Storage Architecture

**Unified Namespace Design** using hierarchical key structure:

```bash
# Namespace: DATA (single KV namespace for all data)

# Dashboard data
dashboard:demo:items                    # Demo dashboard items
dashboard:hackernews:feed              # Cached Hacker News feed

# URL redirections
redirect:{slug}                        # Target URL for redirect slug

# RouterOS functionality
routeros:putio:ipv4                    # Cached IPv4 ranges
routeros:putio:ipv6                    # Cached IPv6 ranges
routeros:putio:script                  # Generated RouterOS script
routeros:putio:metadata:last-updated   # Cache timestamps and status
routeros:putio:metadata:last-error
routeros:putio:metadata:update-in-progress

# Metrics and analytics
metrics:status:{code}                  # HTTP status code counters
metrics:group:{group}                  # Status code group counters (4xx, 5xx)
metrics:routeros:cache-hits            # RouterOS cache performance metrics
metrics:routeros:refresh-count
metrics:redirect:{slug}:count          # Per-redirect usage statistics
metrics:redirect:{slug}:last-accessed

# Authentication and rate limiting
auth:count:{uuid}:requests             # JWT token request counters
auth:count:{uuid}:last-used            # Last usage timestamps
auth:revocation:{uuid}                 # Token revocation flags
ratelimit:ai:alt:{userId}              # AI endpoint rate limiting
```

**KV Utility Pattern:**
All KV operations are abstracted through dedicated modules in `src/kv/`:

```typescript
// Example pattern from src/kv/redirect.ts
export async function getRedirect(env: { DATA: KVNamespace }, slug: string): Promise<string | null> {
  try {
    return await env.DATA.get(`redirect:${slug}`)
  } catch (error) {
    console.error("Error getting redirect", { slug, error })
    return null
  }
}

export async function trackRedirectClick(env: { DATA: KVNamespace }, slug: string): Promise<void> {
  // Update metrics atomically
  await Promise.all([
    incrementCounter(env, `metrics:redirect:${slug}:count`),
    setTimestamp(env, `metrics:redirect:${slug}:last-accessed`)
  ])
}
```

## Authentication System

### JWT Token Structure

Enhanced JWT tokens with enterprise-grade features:

```json
{
  "sub": "ai:alt",              // Hierarchical permission subject
  "iat": 1748375490,            // Issued at timestamp
  "jti": "uuid-here",           // Unique identifier for tracking
  "exp": 1750967490,            // Optional expiration (default: 30 days)
  "maxRequests": 1000           // Optional request limit
}
```

### Authentication Middleware Usage

**For basic authentication:**

```typescript
import { requireAuth, type AuthorizedContext } from "../lib/auth"

async handle(c: Context) {
  const authMiddleware = requireAuth()
  let authResult: Response | void

  try {
    authResult = await authMiddleware(c, async () => {})
  } catch (error) {
    return c.json({ error: "Authentication failed" }, 500)
  }

  if (authResult instanceof Response) {
    return authResult // Auth failed - return the failure response
  }

  // Authentication succeeded - c is now AuthorizedContext
  const authContext = c as AuthorizedContext
  console.log("Authenticated user:", authContext.user.id)

  // Your endpoint logic here
}
```

**For endpoint-specific authorization:**

```typescript
import { authorizeEndpoint } from "../lib/auth"

async handle(c: Context) {
  return authorizeEndpoint("ai", "alt")(c, async () => {
    // This code only executes if user has "ai" or "ai:alt" JWT subject
    return c.json({ message: "Authorized for AI alt text generation" })
  })
}
```

### Token Security Features

- **Default 30-day expiration** for security
- **UUID-based tracking** prevents token confusion
- **Revocation system** via KV storage with instant effect
- **Usage tracking** and request limits
- **Rate limiting** per user/endpoint
- **Hierarchical permissions** (e.g., `ai` grants all AI access, `ai:alt` grants specific access)

### JWT CLI Tool Usage

```bash
# Interactive token creation (recommended)
bun jwt create --interactive

# Standard token with default 30-day expiry
bun jwt create --sub "ai:alt" --description "Alt text generation access"

# Token with custom expiration and limits
bun jwt create --sub "metrics" --expiry "7d" --max-requests 500

# Token management
bun jwt list                    # List all tokens
bun jwt show <uuid>             # Show token details
bun jwt search --sub "ai"       # Search by subject
bun jwt revoke <uuid>           # Get revocation instructions
```

## Frontend Architecture

### Vue.js 3 SPA Structure

**Technology Stack:**

- **Vue 3** with Composition API and `<script setup>` syntax
- **Vite** for development server and build tooling
- **Tailwind CSS + UnoCSS** for styling with auto-generated icons
- **Vue Router** for client-side routing
- **Pinia** for state management
- **Auto-imports** for Vue APIs and components

**Build Integration:**

```typescript
// vite.config.ts key features:
// 1. Auto-import Vue components from frontend/components/
// 2. Auto-import Vue APIs (ref, reactive, etc.)
// 3. UnoCSS for Tailwind + icon integration
// 4. Vue DevTools integration
// 5. Path aliases: @ and ~ point to frontend/
```

**Deployment Flow:**

1. Vite builds Vue.js SPA to `dist/` directory
2. Wrangler deploys Worker with `assets` binding to `dist/`
3. Worker serves static assets via Cloudflare Workers Assets
4. Unmatched routes fall back to `index.html` for SPA routing

### Frontend File Structure

```bash
frontend/
├── App.vue                 # Main application component
├── main.ts                 # Application entry point
├── assets/                 # Static assets and main CSS
├── components/             # Auto-imported Vue components
├── router/                 # Vue Router configuration
├── stores/                 # Pinia state management
└── views/                  # Page-level components
```

## AI Services Integration

### Cloudflare AI Implementation

**Model**: `@cf/llava-hf/llava-1.5-7b-hf` (LLaVA vision-language model)

**Endpoints:**

- `GET /api/ai/alt?image=url` - Process image from URL
- `POST /api/ai/alt` - Process base64 image data

**Features:**

- **Input validation**: Format, size (4MB max), content type checking
- **Rate limiting**: 100 requests/hour per authenticated user
- **Error handling**: Specific error codes for debugging
- **Dual input methods**: URL fetching and direct upload support

**Authentication Requirements:**

- Valid JWT token with `ai` or `ai:alt` subject
- Token can be provided via `Authorization: Bearer` header or `?token=` query parameter

**Example Implementation Pattern:**

```typescript
// From src/endpoints/ai/alt-get.ts
export class AiAlt extends OpenAPIRoute {
  async handle(c: Context) {
    // 1. Authenticate and authorize user
    return authorizeEndpoint("ai", "alt")(c, async () => {
      // 2. Validate and fetch image
      const imageUrl = c.req.query("image")
      const imageData = await fetchAndValidateImage(imageUrl)

      // 3. Check rate limits
      await checkRateLimit(c.env, userId, "ai:alt")

      // 4. Process with Cloudflare AI
      const result = await c.env.AI.run("@cf/llava-hf/llava-1.5-7b-hf", {
        image: Array.from(imageData),
        prompt: "Describe this image in detail for use as alt text..."
      })

      // 5. Track usage and return response
      await trackUsage(c.env, userId)
      return c.json({ altText: result.description, ... })
    })
  }
}
```

## Analytics & Observability

### Multi-Layered Monitoring

**Analytics Engine Integration:**

```typescript
// Comprehensive request tracking
c.env.ANALYTICS.writeDataPoint({
  blobs: [endpoint_type, specific_action, user_id],
  indexes: [category],
  doubles: [response_time_ms, status_code],
  timestamp: requestStartTime
})
```

**Metrics Collection:**

- HTTP status code tracking in KV storage
- Endpoint-specific performance metrics
- Cache hit/miss ratios for RouterOS
- JWT token usage and authentication events
- Rate limiting statistics

**Export Formats:**

- `GET /api/metrics/json` - JSON format for programmatic access
- `GET /api/metrics/yaml` - YAML format for human readability
- `GET /api/metrics/prometheus` - Prometheus format for monitoring systems

### Error Handling Patterns

All endpoints implement consistent error handling:

```typescript
// Standard error response format
return c.json({
  error: "Human-readable error message",
  code: "MACHINE_READABLE_ERROR_CODE",
  details?: "Additional context when helpful"
}, httpStatusCode)
```

## CLI Tools & Administration

### KV Admin Utility (`bin/kv.ts`)

**Environment Requirements:**

```bash
export CLOUDFLARE_API_TOKEN=your-token
export CLOUDFLARE_ACCOUNT_ID=your-account-id
```

**Usage:**

```bash
bun kv backup              # Backup selected data patterns
bun kv backup --all        # Backup all KV data
bun kv restore <file>      # Restore from backup file
bun kv wipe                # Complete KV wipe (with confirmations)
```

**Features:**

- Direct Cloudflare SDK integration (no Wrangler dependency)
- Selective backup with regex pattern matching
- Type-aware value handling (strings vs JSON)
- Safety confirmations for destructive operations

### JWT Management CLI (`bin/jwt.ts`)

**Database Integration:**

- Uses production Cloudflare D1 database (`API_AUTH_METADATA`)
- Automatic schema initialization
- Persistent token metadata across environments

**Security Features:**

- Default 30-day expiration with confirmation required for no-expiry tokens
- Interactive mode with guided prompts
- Token search and filtering capabilities
- Revocation instructions for KV/API-based revocation

## Development Best Practices

### File Editing Guidelines

1. **Always read files first** before editing to understand context and existing patterns
2. **Follow existing code style** and architectural patterns
3. **Use consistent error handling** with proper error codes and messages
4. **Implement proper type safety** with TypeScript and Zod schemas
5. **Add analytics tracking** for new endpoints using established patterns
6. **Test authentication flows** for protected endpoints

### Adding New Endpoints

1. **Create endpoint class** in `src/endpoints/` extending `OpenAPIRoute`
2. **Define Zod schemas** in `src/schemas/` for request/response validation
3. **Register endpoint** in `src/index.ts` with appropriate path prefix
4. **Add KV utilities** in `src/kv/` if KV storage is needed
5. **Implement analytics** tracking with relevant blobs and indexes
6. **Update this documentation** with new endpoint details

### KV Storage Guidelines

1. **Use hierarchical key structure** following the established pattern
2. **Create utility functions** in `src/kv/` for all KV operations
3. **Handle errors gracefully** with proper logging and fallbacks
4. **Initialize default values** in `src/kv/init.ts` for new KV keys
5. **Consider atomicity** for related KV operations

### Authentication Implementation

1. **Use existing middleware** (`requireAuth`, `authorizeEndpoint`) rather than custom auth
2. **Handle auth failures properly** by checking middleware return values
3. **Implement proper error responses** for different failure scenarios
4. **Use hierarchical subjects** for fine-grained permissions
5. **Track usage and metrics** for authenticated endpoints

## External Service Integration

**Cloudflare Services:**

- **Workers**: Core runtime with Node.js compatibility
- **KV Storage**: Unified data storage with global replication
- **Analytics Engine**: High-performance request tracking
- **AI Workers**: LLaVA model for image processing
- **Workers Assets**: Static file serving for Vue.js SPA
- **D1 Database**: JWT token metadata storage

**Third-Party APIs:**

- **put.io API**: IP range fetching for RouterOS script generation
- **RSS feeds**: Dashboard data source integration

## Deployment & Production

### Build Process

```bash
# Complete build pipeline
bun run build
# 1. Clean previous builds
# 2. Generate Cloudflare Workers types
# 3. Build Vue.js frontend to dist/
# 4. Build Worker with Wrangler

# Deploy to production
bun run deploy
```

### Production Configuration

**Wrangler Configuration (`wrangler.jsonc`):**

- Custom domain routing for `dave.io` and `www.dave.io`
- Workers Assets binding for Vue.js SPA serving
- KV namespace and Analytics Engine bindings
- AI binding for Cloudflare AI integration
- Node.js compatibility for JWT and other libraries

**Environment Variables in Production:**

```bash
# Set via Wrangler secrets (write-only for security)
bun run wrangler secret put API_JWT_SECRET
```

## Troubleshooting Guide

### Common Issues

**TypeScript Errors:**

- Run `bun run types` to regenerate worker-configuration.d.ts
- Ensure proper type references in source files
- Check Zod schema definitions match endpoint usage

**Authentication Failures:**

- Verify JWT secret consistency between CLI and Worker
- Check token expiration and revocation status
- Ensure proper middleware usage patterns

**KV Storage Issues:**

- Check key naming follows hierarchical pattern
- Verify KV namespace binding in wrangler.jsonc
- Use KV utility functions rather than direct KV calls

**Build Failures:**

- Run `bun run clean` to remove generated files
- Check Node.js compatibility flags in wrangler.jsonc
- Verify all dependencies are properly installed

### Development Workflow

1. **Start development**: `bun run dev` for unified frontend+backend
2. **Make changes**: Edit files following established patterns
3. **Test locally**: Use browser for frontend, API endpoints for backend
4. **Type checking**: `bun run typecheck` before committing
5. **Linting**: `bun run lint` to ensure code quality
6. **Deploy**: `bun run deploy` when ready for production

This documentation provides AI agents with comprehensive understanding of the dave.io codebase architecture, development patterns, and best practices for making effective contributions to the project.
